<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[装饰器模式]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;装饰器模式属于结构型模式，遵循开闭原则，合成复用原则。装饰器模式可以在不改变原类文件和继承的情况下扩展功能。 实现 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚好最近在选购耳机，就以耳机为例说明装饰器模式。首先，实现耳机接口，耳机是一对转换单元，它接接收播放器发出的电讯号，利用贴近耳朵的扬声器将其转化成音波，所以耳机应该具有接收和播放连个方法，如下： 123456public interface Earphones &#123; //接收电信号 void receive(); //播放声音 void play();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着是具体的耳机实现类，一般我们可以简单的将耳机分为有线耳机和蓝牙耳机，下面以此创建两个实现耳机接口的具类WiredEarphones和BluetoothEarphones，如下： 12345678910111213141516171819202122232425//有线耳机public class WiredEarphones implements Earphones &#123; @Override public void receive() &#123; System.out.println("数据线接收"); &#125; @Override public void play() &#123; System.out.println("播放声音"); &#125;&#125;//蓝牙耳机public class BluetoothEarphones implements Earphones &#123; @Override public void receive() &#123; System.out.println("蓝牙接收"); &#125; @Override public void play() &#123; System.out.println("播放声音"); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着我们想要防水耳机且不管他是有线还是蓝牙，这是该怎么做？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先不是所有的耳机都防水，所以在耳机接口Earphones添加防水方法就不太合适，那么一般此时我们会按照继承的思想创造防水有线耳机WaterproofWiredEarphones和防水蓝牙耳机WaterproofBluetoothEarphones，而在这里我们改用用装饰器模式实现防水耳机类WaterproofEarphones，如下： 1234567891011121314151617public class WaterproofEarphones &#123; private Earphones earphones; public WaterproofEarphones(Earphones earphones) &#123; this.earphones = earphones; &#125; public void receive() &#123; earphones.receive(); System.out.println("防水"); &#125; public void play() &#123; earphones.play(); System.out.println("防水"); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来我们在main方法中进行测试： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; WaterproofEarphones bluetooth = new WaterproofEarphones(new BluetoothEarphones()); WaterproofEarphones wired = new WaterproofEarphones(new WiredEarphones()); bluetooth.receive(); wired.receive(); &#125;&#125;/******输出结果****** 蓝牙接收* 防水* 数据线接收* 防水*******************/ 优点 装饰模式相比可以扩展类的功能，且比继承更加灵活 装饰模式可以根据不同的需求，进行不同的组合 缺点 虽然比继承更加灵活，但也更加复杂 实际应用 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java中的FilterInputStream，BufferedInputStream，SynchronizedList等都是使用了装饰器模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[setDefaultKeyMode]]></title>
    <url>%2F2019%2F08%2F05%2FsetDefaultKeyMode%2F</url>
    <content type="text"><![CDATA[概要&#160; &#160; &#160; &#160;本文介绍Activity中setDefaultKeyMode(@DefaultKeyMode int mode)方法的用法，setDefaultKeyMode(@DefaultKeyMode int mode)用于设置按键模式。&#160; &#160; &#160; &#160;setDefaultKeyMode(@DefaultKeyMode int mode)有五种可选的按键模式分别如下： DEFAULT_KEYS_DIALER DEFAULT_KEYS_DISABLE DEFAULT_KEYS_SEARCH_LOCAL DEFAULT_KEYS_SEARCH_GLOBAL DEFAULT_KEYS_SHORTCUT 准备&#160; &#160; &#160; &#160;因为现在的手机几乎都没有键盘，所以在实验setDefaultKeyMode(@DefaultKeyMode int mode)这五种模式之前我们需要调出软键盘。下面的代码可以帮助调出软键盘: 12InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);inputMethodManager.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); DEFAULT_KEYS_DISABLE&#160; &#160; &#160; &#160;使用该模式当你点击键盘时，不会触发任何操作。 DEFAULT_KEYS_DIALER&#160; &#160; &#160; &#160;使用该模式会打开电话拨号器如图： DEFAULT_KEYS_SHORTCUT&#160; &#160; &#160; &#160;使用该模式可以使键盘按键成为菜单的快捷方式,因此你需要先构建菜单。&#160; &#160; &#160; &#160;在Activity中重写onPrepareOptionsMenu(Menu menu)方法构建菜单，示例代码如下： 1234567891011121314151617181920212223242526@Override public boolean onPrepareOptionsMenu(Menu menu) &#123; // TODO Auto-generated method stub super.onPrepareOptionsMenu(menu); menu.clear(); menu.removeItem(0); menu.removeItem(1); menu.add( 0, 0, 0, &quot;Show 0&quot;).setShortcut(&apos;0&apos;, &apos;0&apos;).setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener()&#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this,&quot;DEFAULT_KEYS_SHORTCUT:0&quot;,Toast.LENGTH_SHORT).show(); return true; &#125;&#125;); menu.add( 0, 1, 0, &quot;Show 1&quot;).setShortcut(&apos;1&apos;, &apos;1&apos;).setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener()&#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this,&quot;DEFAULT_KEYS_SHORTCUT:1&quot;,Toast.LENGTH_SHORT).show(); return true; &#125;&#125;); return true; &#125; &#160; &#160; &#160; &#160;上面所示代码可以构建出如下图所示菜单： &#160; &#160; &#160; &#160;点击“Show 0”或“Show 1”会分别展示Toast。&#160; &#160; &#160; &#160;这里有个问题需要注意下:此时我点击定义好的快捷键，即软键盘中的0和1并没有触发弹出Toast，但当我把示列Activity的父类从AppCompatActivity更换为AppCompatActivity是就成功触发了，具体原因待查。测试结果如下： DEFAULT_KEYS_SEARCH_LOCAL&#160; &#160; &#160; &#160;使用该模式当你点击键盘时，会调用应用内部搜索。&#160; &#160; &#160; &#160;当然要实现内部搜索，你需要去定义内部搜索，在AndroidManifest中定义如下标签： 1234567891011&lt;meta-data--&gt; &lt;!--android:name=&quot;android.app.default_searchable&quot;--&gt; &lt;!--android:value=&quot;.SearchableActivity&quot; /&gt;&lt;activity android:name=&quot;.SearchableActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEARCH&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.searchable&quot; android:resource=&quot;@xml/searchable&quot; /&gt;&lt;/activity&gt; &#160; &#160; &#160; &#160;searchable.xml定义了一些属性。具体可以参考https://developer.android.com/guide/topics/search/searchable-config.html SearchableActivity用来处理搜素的逻辑。我在这里只是简单的将搜索的内容通过TextView展示出来。测试如下： DEFAULT_KEYS_SEARCH_GLOBAL 使用该模式当你点击键盘时，会调用系统的全局搜索。如下图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Api</tag>
      </tags>
  </entry>
</search>
