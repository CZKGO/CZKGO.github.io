<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CZKGO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-05T14:54:23.577Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CZKGO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>装饰器模式</title>
    <link href="http://yoursite.com/2019/08/05/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/05/装饰器模式/</id>
    <published>2019-08-05T14:50:00.000Z</published>
    <updated>2019-08-05T14:54:23.577Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;装饰器模式属于结构型模式，遵循开闭原则，合成复用原则。装饰器模式可以在不改变原类文件和继承的情况下扩展功能。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚好最近在选购耳机，就以耳机为例说明装饰器模式。首先，实现耳机接口，耳机是一对转换单元，它接接收播放器发出的电讯号，利用贴近耳朵的扬声器将其转化成音波，所以耳机应该具有接收和播放连个方法，如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Earphones</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收电信号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//播放声音</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着是具体的耳机实现类，一般我们可以简单的将耳机分为有线耳机和蓝牙耳机，下面以此创建两个实现耳机接口的具类WiredEarphones和BluetoothEarphones，如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有线耳机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiredEarphones</span> <span class="keyword">implements</span> <span class="title">Earphones</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"数据线接收"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"播放声音"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝牙耳机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluetoothEarphones</span> <span class="keyword">implements</span> <span class="title">Earphones</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝牙接收"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"播放声音"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着我们想要防水耳机且不管他是有线还是蓝牙，这是该怎么做？</p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先不是所有的耳机都防水，所以在耳机接口Earphones添加防水方法就不太合适，那么一般此时我们会按照继承的思想创造防水有线耳机WaterproofWiredEarphones和防水蓝牙耳机WaterproofBluetoothEarphones，而在这里我们改用用装饰器模式实现防水耳机类WaterproofEarphones，如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterproofEarphones</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Earphones earphones;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaterproofEarphones</span><span class="params">(Earphones earphones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.earphones = earphones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        earphones.receive();</span><br><span class="line">        System.out.println(<span class="string">"防水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        earphones.play();</span><br><span class="line">        System.out.println(<span class="string">"防水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来我们在main方法中进行测试：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaterproofEarphones bluetooth = <span class="keyword">new</span> WaterproofEarphones(<span class="keyword">new</span> BluetoothEarphones());</span><br><span class="line">        WaterproofEarphones wired = <span class="keyword">new</span> WaterproofEarphones(<span class="keyword">new</span> WiredEarphones());</span><br><span class="line">        bluetooth.receive();</span><br><span class="line">        wired.receive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******输出结果*****</span></span><br><span class="line"><span class="comment">* 蓝牙接收</span></span><br><span class="line"><span class="comment">* 防水</span></span><br><span class="line"><span class="comment">* 数据线接收</span></span><br><span class="line"><span class="comment">* 防水</span></span><br><span class="line"><span class="comment">*******************/</span></span><br></pre></td></tr></table></figure></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>装饰模式相比可以扩展类的功能，且比继承更加灵活</li><li>装饰模式可以根据不同的需求，进行不同的组合</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>虽然比继承更加灵活，但也更加复杂</li></ul><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java中的FilterInputStream，BufferedInputStream，SynchronizedList等都是使用了装饰器模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;装饰器模式属于结构型模式，遵循开闭原则，合成复用原则。
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>setDefaultKeyMode</title>
    <link href="http://yoursite.com/2019/08/05/setDefaultKeyMode/"/>
    <id>http://yoursite.com/2019/08/05/setDefaultKeyMode/</id>
    <published>2019-08-05T13:56:00.000Z</published>
    <updated>2019-08-05T14:00:02.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>&#160; &#160; &#160; &#160;本文介绍Activity中setDefaultKeyMode(@DefaultKeyMode int mode)方法的用法，setDefaultKeyMode(@DefaultKeyMode int mode)用于设置按键模式。<br>&#160; &#160; &#160; &#160;setDefaultKeyMode(@DefaultKeyMode int mode)有五种可选的按键模式分别如下：</p><ul><li>DEFAULT_KEYS_DIALER</li><li>DEFAULT_KEYS_DISABLE</li><li>DEFAULT_KEYS_SEARCH_LOCAL</li><li>DEFAULT_KEYS_SEARCH_GLOBAL</li><li>DEFAULT_KEYS_SHORTCUT</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>&#160; &#160; &#160; &#160;因为现在的手机几乎都没有键盘，所以在实验setDefaultKeyMode(@DefaultKeyMode int mode)这五种模式之前我们需要调出软键盘。下面的代码可以帮助调出软键盘:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class="line">inputMethodManager.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);</span><br></pre></td></tr></table></figure><h4 id="DEFAULT-KEYS-DISABLE"><a href="#DEFAULT-KEYS-DISABLE" class="headerlink" title="DEFAULT_KEYS_DISABLE"></a><em>DEFAULT_KEYS_DISABLE</em></h4><p>&#160; &#160; &#160; &#160;使用该模式当你点击键盘时，不会触发任何操作。</p><h4 id="DEFAULT-KEYS-DIALER"><a href="#DEFAULT-KEYS-DIALER" class="headerlink" title="DEFAULT_KEYS_DIALER"></a><em>DEFAULT_KEYS_DIALER</em></h4><p>&#160; &#160; &#160; &#160;使用该模式会打开电话拨号器如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5989922-d9521a60884c1b85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="图片.png"></p><h4 id="DEFAULT-KEYS-SHORTCUT"><a href="#DEFAULT-KEYS-SHORTCUT" class="headerlink" title="DEFAULT_KEYS_SHORTCUT"></a><em>DEFAULT_KEYS_SHORTCUT</em></h4><p>&#160; &#160; &#160; &#160;使用该模式可以使键盘按键成为菜单的快捷方式,因此你需要先构建菜单。<br>&#160; &#160; &#160; &#160;在Activity中重写onPrepareOptionsMenu(Menu menu)方法构建菜单，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean onPrepareOptionsMenu(Menu menu) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onPrepareOptionsMenu(menu);</span><br><span class="line">        menu.clear();</span><br><span class="line">        menu.removeItem(0);</span><br><span class="line">        menu.removeItem(1);</span><br><span class="line">        menu.add( 0, 0, 0, &quot;Show 0&quot;).setShortcut(&apos;0&apos;, &apos;0&apos;).setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onMenuItemClick(MenuItem item) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                Toast.makeText(MainActivity.this,&quot;DEFAULT_KEYS_SHORTCUT:0&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">        menu.add( 0, 1, 0, &quot;Show 1&quot;).setShortcut(&apos;1&apos;, &apos;1&apos;).setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onMenuItemClick(MenuItem item) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                Toast.makeText(MainActivity.this,&quot;DEFAULT_KEYS_SHORTCUT:1&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;&#125;);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160;上面所示代码可以构建出如下图所示菜单：</p><p><img src="http://upload-images.jianshu.io/upload_images/5989922-86a1041d7f5001e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="Screenshot_2017-10-15-21-04-36-680_KeyMode.png"><br>&#160; &#160; &#160; &#160;点击“Show 0”或“Show 1”会分别展示Toast。<br>&#160; &#160; &#160; &#160;<strong>这里有个问题需要注意下:</strong>此时我点击定义好的快捷键，即软键盘中的0和1并没有触发弹出Toast，但当我把示列Activity的父类从AppCompatActivity更换为AppCompatActivity是就成功触发了，具体原因待查。测试结果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5989922-870ebe458e65de2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="Screenshot_2017-10-15-21-17-55-429_KeyMode.png"></p><h4 id="DEFAULT-KEYS-SEARCH-LOCAL"><a href="#DEFAULT-KEYS-SEARCH-LOCAL" class="headerlink" title="DEFAULT_KEYS_SEARCH_LOCAL"></a><em>DEFAULT_KEYS_SEARCH_LOCAL</em></h4><p>&#160; &#160; &#160; &#160;使用该模式当你点击键盘时，会调用应用内部搜索。<br>&#160; &#160; &#160; &#160;当然要实现内部搜索，你需要去定义内部搜索，在AndroidManifest中定义如下标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data--&gt;</span><br><span class="line">            &lt;!--android:name=&quot;android.app.default_searchable&quot;--&gt;</span><br><span class="line">            &lt;!--android:value=&quot;.SearchableActivity&quot; /&gt;</span><br><span class="line">&lt;activity android:name=&quot;.SearchableActivity&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.SEARCH&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">            &lt;meta-data</span><br><span class="line">                android:name=&quot;android.app.searchable&quot;</span><br><span class="line">                android:resource=&quot;@xml/searchable&quot; /&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160;searchable.xml定义了一些属性。具体可以参考<a href="https://developer.android.com/guide/topics/search/searchable-config.html" target="_blank" rel="noopener">https://developer.android.com/guide/topics/search/searchable-config.html</a> SearchableActivity用来处理搜素的逻辑。我在这里只是简单的将搜索的内容通过TextView展示出来。测试如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5989922-5c5eb9084b154d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="图片.png"></p><h4 id="DEFAULT-KEYS-SEARCH-GLOBAL"><a href="#DEFAULT-KEYS-SEARCH-GLOBAL" class="headerlink" title="DEFAULT_KEYS_SEARCH_GLOBAL"></a><em>DEFAULT_KEYS_SEARCH_GLOBAL</em></h4><p>  使用该模式当你点击键盘时，会调用系统的全局搜索。如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5989922-8b558d0801ef24d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="图片.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;本文介绍Activity中setDefaultKeyMode(@DefaultKeyM
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android Api" scheme="http://yoursite.com/tags/Android-Api/"/>
    
  </entry>
  
</feed>
